import json
from django.http.response import HttpResponse
from django.shortcuts import render, redirect
from django.http import JsonResponse
from .forms import CustomUserCreationForm
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from .models import Lab, Flag, UserLab
from django.urls import reverse
from django.core import serializers
import subprocess
from random import randrange
from datetime import date
# pyvmomi modules :
from .pyvmomi_functions.samples import vm_power_on, vm_power_off, find_vm_uuid, find_vm_name, create_snapshot, revert_to_snapshot
from .tools.service_instance import connect
from pyVim.connect import Disconnect
#The register's view method
def register(request):
    if request.method == "POST" :
        form = CustomUserCreationForm(request.POST)
        if form.is_valid() :
            user = form.save()
            login(request,user)
            return redirect(reverse('ps-index'))

    form = CustomUserCreationForm()
    data = {
        'form':form
    }
    return render(request,'registration/register.html',data)

# The dashboard's view method
@login_required
def home(request):
    total_labs = str(Lab.objects.count())
    user = request.user
    ongoing_labs = str(len(list(user.userlab_set.filter(active=True))))
    total_played = str(len(list(user.userlab_set.filter(completed=True))))
    d = date.today()
    new_labs = Lab.objects.filter(created_at__lte=d, created_at__gte=date(d.year,d.month,1))
    users = User.objects.filter(is_active="True", is_staff="False", is_superuser="False").order_by('-date_joined')[:5]
    context = {
        'users'          : users,
        'new_labs'       : new_labs,
        'total_labs'     : total_labs,
        'ongoing_labs'   : ongoing_labs,
        'total_played'   : total_played
    }
    return render(request,'ps-index.html',context)

def statical_info(request):
    total_labs = str(Lab.objects.count())
    user = request.user
    ongoing_labs = str(len(list(user.userlab_set.filter(active=True))))
    total_played = str(len(list(user.userlab_set.filter(completed=True))))
    d = date.today()
    new_this_month = str(len(list(Lab.objects.all().filter(created_at__lte=d, created_at__gte=date(d.year,d.month,1)))))
    data = {
        'total_labs'     : total_labs,
        'ongoing_labs'   : ongoing_labs,
        'total_played'   : total_played,
        'new_this_month' : new_this_month
    }
    return JsonResponse(data)

# The list of challenges of Category = category and Type = type 
@login_required
def list_labs(request, category, type):
    labs = Lab.objects.filter(category=category,type=type)

    data = {
        'labs':labs,
        'count' :labs.count()
    }
    return render(request,'listing.html',data)


# The challenge details :
@login_required
def lab_detail(request, lid):
    if request.method == 'POST' :
        json_data = json.loads(request.body)
        # <Attack-Box>
        # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        
        # Starting the Attack-Box Machine
        if json_data['action'] == 'startInstance' :
            # 1- Starting the attacking Box:
            request.session['started'] = False
            powered_on = False
            # 1.1- Connecting to the esxi host 
            si = connect()
            # 1.2- Find the attack-Box machine
            vm = find_vm_name(si,"Kali-Attack-Box")
            if vm is None :
                print("Unable to locate a machine with that name")
                link = None
            # 1.3- PowerOn the machine
            else :
                # 1.3.1- check if the machine is already powered-on
                if vm.summary.runtime.powerState == "poweredOn" :
                    print("Machine already On")
                    request.session['started'] = True
                    powered_on = True # indicates that the operation is done succefuly.
                else :       
                    powered_on = vm_power_on(si,vm.name)
                    if powered_on :
                        request.session['started'] = True
                        print("Machine Powered-On succefully")
                    else :
                        request.session['started'] = False
                        print("Unable to PowerOn the Machine")
                
                link = "https://10.0.24.240/ui/#/console/7"
            #****************************************************************************
            """
            user = request.user
            lab = Lab.objects.get(id=lid)
            # 1.1 Verifying if the userlab doesn't exist before (active=false) :
            try :
                userlab = UserLab.objects.get(userId = user, labId = lab)
                userlab.active = True
                userlab.save()
            except :
                userlab = UserLab(userId=user, labId = lab)
                userlab.save()
            # dealing with ttyd
            # 1- Picking a random port number from the list of open ports (Not yet):
            # 1.1- Because there is no list yet we will generate random numbers.
            # random_number = randrange(1000)
            # port = 10000 + lid + random_number
            # cmd_port = f'-p {port}'
            # 2. Executing the ttyd command with subprocess.
            # child_process = subprocess.Popen(['ttyd',cmd_port,'bash'])
            # pid = child_process.pid
            # 3. Storing the process id in the session to use it when quit, stop, continue
            # request.session[str(lid)] = pid
            # link = f'http://localhost:{port}'
            # 4- Storing the link in the UserLab table to use it later.
            # userlab.machineLink = link
            # userlab.save()
            ######
            # New Code 
            """
            #link = userlab.machineLink
            Disconnect(si)
            started = request.session['started']
            print(started)
            return JsonResponse({'link':link}, safe=False)

        # Terminating the Attack-Box Machine 
        if json_data['action'] == 'terminateInstance': 
            # 1- Stopping the attacking Box:
            # 1.1- checking if the machine is On:
            started = request.session['started']
            print(started)
            if started == True :
                # 1.1- Connecting to the esxi host 
                si = connect()
                print(si)
                # 1.2- Find the attack-Box machine
                vm = find_vm_name(si,"Kali-Attack-Box")
                if vm is None :
                    print("Unable to locate a machine with that name")
                    link = None
                else:
                    # 1.3- PowerOff the machine
                    # 1.3.1- Another layer of verification : testing the powerState of the machine 
                    if vm.summary.runtime.powerState == "poweredOff" :
                        print("Machine already Off due to other operation,contact the admin")
                        request.session['started'] = False
                    else:
                        powered_off = vm_power_off(si,"Kali-Attack-Box")
                        if powered_off :
                            request.session['started'] = False
                            print("Machine Powered-Off succefully")
                        else :
                            request.session['started'] = True
                            print("Unable to PowerOff the Machine")
        # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        # </attack-Box>

            # <lab>
            # This section is for starting a new lab 

            # 1- Turning the active field of userlab to False 
            """
            user = request.user
            lab = Lab.objects.get(id=lid)
            userlab = UserLab.objects.get(userId=user, labId = lab)
            userlab.active = False
            userlab.machineLink = ''
            userlab.save()                  
            # dealing with ttyd
            pid = request.session[str(lid)]
            subprocess.call(['kill','-SIGKILL',str(pid)])
            del request.session[str(lid)]
            """
            return  JsonResponse({'message':'Attacking-Machine PoweredOff'}, safe=False)
        # Stopping the Lab

        # if json_data['action'] == 'stop':
        #     # dealing with ttyd
        #     pid = request.session[str(lid)]
        #     subprocess.call(['kill','-STOP',str(pid)])
            
        #     return  JsonResponse({'message':'Stopped Successfuly'}, safe=False)
        # # Continuing the Lab :
        # if json_data['action'] == 'continue':   
        #     # dealing with ttyd
        #     pid = request.session[str(lid)]
        #     subprocess.call(['kill','-CONT',str(pid)])
        #     return  JsonResponse({'message':'Continue Lab'}, safe=False)
    
    # If the request method is get and the lab is already started we should include active=True into the data sent to the template.
    lab = Lab.objects.get(id=lid)
    user = request.user
    try :
        userlab = UserLab.objects.get(userId=user, labId=lab, active=True)
        data = {
            'lab' : lab,
            'active' : True,
            'lab_link' : userlab.machineLink 
        }
        return render(request,'lab_detail.html', data)
            
    except :
        data = {
            'lab' : lab,
            'active': False
        }
        return render(request,'lab_detail.html',data)


# The Lab page
@login_required
def ongoing_labs(request):
    user = request.user
    # creating a list of userlab objects
    userlabs = list(user.userlab_set.filter(active=True))
    # extract the list of active labs (list of lab objects) for a specifique user
    labs = [userlab.labId for userlab in userlabs]
    data = {
        'labs':labs
    }
    return render(request,'ongoinglabs.html',data)
def labs_component(request):
    user = request.user
    # creating a list of userlab objects
    userlabs = list(user.userlab_set.filter(active=True))
    # extract the list of active labs (list of lab objects) for a specifique user
    labs = [userlab.labId for userlab in userlabs]
    data = {
        'labs':labs
    }
    return render(request,'labs_component.html',data)

# The redteam's view method
@login_required
def red_team(request):
    return render(request,'red-team.html',{})

@login_required
def profile(request):
    return render(request,'registration/profile.html',{})

    
    
    

# Create your views here.
