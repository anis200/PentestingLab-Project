import json
from urllib import request
from django.http.response import HttpResponse
from django.shortcuts import render, redirect
from django.http import JsonResponse
from .forms import CustomUserCreationForm
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from .models import (
    Container,
    Lab,
    Flag,
    LabCountdownTimer,
    UserLab,
    AttackBox,
    AttackBoxCountdownTimer,
)
from django.urls import reverse
from random import randrange
from datetime import date

# pyvmomi modules :
from .pyvmomi_functions.samples import (
    get_snapshots_by_name_recursively,
    vm_power_on,
    vm_power_off,
    find_vm_uuid,
    find_vm_name,
    create_snapshot,
    revert_to_snapshot,
)
from .tools.service_instance import connect

from .lab_management.lab import port_generator, connect_docker
from pyVim.connect import Disconnect

# The register's view method
def register(request):
    if request.method == "POST":
        form = CustomUserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            return redirect(reverse("ps-index"))

    form = CustomUserCreationForm()
    data = {"form": form}
    return render(request, "registration/register.html", data)


# The dashboard's view method
@login_required
def home(request):
    total_labs = str(Lab.objects.count())
    user = request.user
    ongoing_labs = str(len(list(user.userlab_set.filter(active=True))))
    total_played = str(len(list(user.userlab_set.filter(completed=True))))
    d = date.today()
    new_labs = Lab.objects.filter(
        created_at__lte=d, created_at__gte=date(d.year, d.month, 1)
    )
    users = User.objects.filter(
        is_active="True", is_staff="False", is_superuser="False"
    ).order_by("-date_joined")[:5]
    context = {
        "users": users,
        "new_labs": new_labs,
        "total_labs": total_labs,
        "ongoing_labs": ongoing_labs,
        "total_played": total_played,
    }
    return render(request, "ps-index.html", context)


@login_required
def statical_info(request):
    total_labs = str(Lab.objects.count())
    user = request.user
    ongoing_labs = str(len(list(user.userlab_set.filter(active=True))))
    total_played = str(len(list(user.userlab_set.filter(completed=True))))
    d = date.today()
    new_this_month = str(
        len(
            list(
                Lab.objects.all().filter(
                    created_at__lte=d, created_at__gte=date(d.year, d.month, 1)
                )
            )
        )
    )
    data = {
        "total_labs": total_labs,
        "ongoing_labs": ongoing_labs,
        "total_played": total_played,
        "new_this_month": new_this_month,
    }
    return JsonResponse(data)


# The list of challenges of Category = category and Type = type
@login_required
def list_labs(request, category, type):
    labs = Lab.objects.filter(category=category, type=type)
    data = {"labs": labs, "count": labs.count()}
    return render(request, "listing.html", data)


@login_required
def list_completed_labs(request):
    user = request.user
    userlabs = list(user.userlab_set.filter(completed=True))
    labs = [userlab.lab for userlab in userlabs]
    data = {"labs": labs}
    return render(request, "completed_labs.html", data)


# The challenge details :
@login_required
def lab_detail(request, lid):

    # If the request method is get and the lab is already started we should include active=True into the data sent to the template.
    lab = Lab.objects.get(id=lid)
    user = request.user
    att_box = AttackBox.objects.get(name="Kali-Attack-Box", user=user)
    try:
        userlab = UserLab.objects.get(user=user, lab=lab, active=True)
        lab_timer = LabCountdownTimer.objects.get(user_lab=userlab)
        remaining_time = lab_timer.remaining_time_in_minutes()
        data = {
            "lab": lab,
            "active": True,
            "started": att_box.poweredOn,
            "lab_link": userlab.labLink,
            "remaining_time": remaining_time,
        }
        return render(request, "lab_detail.html", data)

    except:
        data = {"lab": lab, "active": False, "started": att_box.poweredOn}
        return render(request, "lab_detail.html", data)


@login_required
def start_lab(request, lid):
    if request.method == "POST":
        json_data = json.loads(request.body)
        # +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        if json_data["action"] == "start":
            user = request.user
            lab = Lab.objects.get(id=lid)

            started = AttackBox.objects.get(name="Kali-Attack-Box", user=user).poweredOn
            if started:
                # 1.1 Verifying if the userlab exist before (active=false) :
                try:
                    userlab = UserLab.objects.get(user=user, lab=lab)
                    userlab.active = True
                    # steps :
                    # 1- we must generate the random port for the lab to be accessed at.
                    host_port = str(port_generator())
                    labLink = f"http://10.0.42.239:" + host_port + "/"
                    userlab.labLink = labLink
                    # 2- retreive the image name and the docker_port from the lab object.
                    docker_image = lab.docker_image
                    docker_port = lab.docker_container_port
                    # 2- connecting to the docker engine
                    docker_client = connect_docker()
                    # - creating a new container instance of an image, the image must be a field in the lab relation : 1 lab <=> 1 image.
                    container = docker_client.containers.run(
                        str(docker_image),
                        detach=True,
                        ports={f"{docker_port}/tcp": str(host_port)},
                    )
                    short_id = str(container.short_id)
                    container_name = str(container.name)
                    container_object = Container(
                        short_id=short_id,
                        name=container_name,
                        host_port=host_port,
                    )
                    container_object.save()
                    # - returning the info of the container and save them on the containers relation.
                    # - creating a new userlab with the new created container.
                    userlab.container = container_object
                    userlab.save()
                except:
                    # steps :
                    # 1- we must generate the random port for the lab to be accessed at.
                    host_port = str(port_generator())
                    labLink = f"http://10.0.42.239:" + host_port + "/"
                    # 2- retreive the image name and the docker_port from the lab object.
                    docker_image = lab.docker_image
                    docker_port = lab.docker_container_port
                    # 2- connecting to the docker engine
                    docker_client = connect_docker()
                    # - creating a new container instance of an image, the image must be a field in the lab relation : 1 lab <=> 1 image.
                    container = docker_client.containers.run(
                        str(docker_image),
                        detach=True,
                        ports={f"{docker_port}/tcp": str(host_port)},
                    )

                    # - returning the info of the container and save them on the containers relation.
                    # creating a container instance in the Container relation
                    short_id = str(container.short_id)
                    name = str(container.name)
                    container_object = Container(
                        short_id=short_id,
                        name=name,
                        host_port=host_port,
                    )
                    container_object.save()

                    # - creating a new userlab with the new created container.
                    userlab = UserLab(
                        user=user,
                        lab=lab,
                        container=container_object,
                        labLink=labLink,
                    )  # we must add the machine link !
                    userlab.save()

                # launching our Countdown Timer by creating a countdownTimer object with duration_in_minutes == 91
                timer = LabCountdownTimer.objects.create(
                    duration_in_minutes=2,  # Set it Later To : 91
                    state=LabCountdownTimer.STATE.RUNNING,
                    user_lab=userlab,
                )
                return JsonResponse({"link": labLink}, safe=False)
            else:
                return JsonResponse(
                    {"message": "Please Power On the Attack Machine !"}, safe=False
                )


@login_required
def end_lab(request, lid):
    if request.method == "POST":
        json_data = json.loads(request.body)
        if json_data["action"] == "quit" or json_data["action"] == "done+quit":
            # 1- Turning the active field of userlab to False
            user = request.user
            lab = Lab.objects.get(id=lid)
            userlab = UserLab.objects.get(user=user, lab=lab)
            userlab.active = False
            userlab.labLink = ""
            if json_data["action"] == "done+quit":
                userlab.completed = True
            userlab.save()
            container_object = userlab.container
            # stopping, then removing the container using the docker's python SDK
            docker_client = connect_docker()
            container_instance = docker_client.containers.get(container_object.short_id)
            container_instance.stop()
            container_instance.remove()
            # removing the container object from the database :
            container_object.delete()
            # stopping the CountdownTimer by deleting the LabCountdownTimer object
            # Firstly we must locate it :
            timer_object = LabCountdownTimer.objects.get(user_lab=userlab)
            timer_object.delete()

            return JsonResponse({"message": "Lab Ended Successefuly"}, safe=False)


# The Attack-Box main View
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
@login_required
def attack_box_start(request):
    if request.method == "POST":
        json_data = json.loads(request.body)
        # <Attack-Box>
        # Starting the Attack-Box Machine
        if json_data["action"] == "startInstance":
            # 1- Starting the attacking Box:
            user = request.user
            att_box = AttackBox.objects.get(name="Kali-Attack-Box", user=user)
            powered_on = False
            # 1.1- Connecting to the esxi host
            si = connect()
            # 1.2- Find the attack-Box machine
            vm = find_vm_name(si, "Kali-Attack-Box")
            if vm is None:
                print("Unable to locate a machine with that name")
                link = None
            # 1.3- PowerOn the machine
            else:
                # 1.3.1- check if the machine is already powered-on
                if vm.summary.runtime.powerState == "poweredOn":
                    print("Machine already On")
                    # request.session['started'] = True
                    att_box.poweredOn = True
                    att_box.save()
                    powered_on = True  # indicates that the operation is done succefuly.
                    # Launching our Countdown Timer by creating a countdownTimer object with duration_in_minutes == 91
                    timer = AttackBoxCountdownTimer.objects.create(
                        duration_in_minutes=2,  # Set it Later To : 91
                        state=AttackBoxCountdownTimer.STATE.RUNNING,
                        attack_box=att_box,
                    )
                else:
                    # Normal Behavior
                    powered_on = vm_power_on(si, vm.name)
                    if powered_on:
                        # Here we launch our Countdown Timer by creating a countdownTimer object with duration_in_minutes == 91
                        timer = AttackBoxCountdownTimer.objects.create(
                            duration_in_minutes=2,  # Set it Later To : 91
                            state=AttackBoxCountdownTimer.STATE.RUNNING,
                            attack_box=att_box,
                        )
                        print("Machine Powered-On succefully")
                        att_box.poweredOn = True
                        att_box.save()
                        # Create a snapshot of the current state if it doesn't exist
                        snapshots = vm.snapshot.rootSnapshotList
                        snap_obj = get_snapshots_by_name_recursively(
                            snapshots, "Initial State"
                        )
                        if len(snap_obj) == 1:
                            print("Snapshot already exists !")
                        else:
                            snap = create_snapshot(
                                si, "Kali-Attack-Box", "Initial State", ""
                            )
                            if snap:
                                print("Snapshot Created Successfuly !")
                            else:
                                print(
                                    "Unable To Create the snapshot of the current state !"
                                )
                    else:
                        # request.session['started'] = False
                        print("Unable to PowerOn the Machine")

                link = AttackBox.objects.get(
                    name="Kali-Attack-Box", user=user
                ).machineLink
            Disconnect(si)
            # started = request.session['started']
            print(att_box.poweredOn)
            return JsonResponse({"link": link}, safe=False)


# attack_box_terminate
@login_required
def attack_box_terminate(request):
    # Terminating the Attack-Box Machine
    if request.method == "POST":
        json_data = json.loads(request.body)
        if json_data["action"] == "terminateInstance":
            # 1- Stopping the attacking Box:
            # 1.1- checking if the machine is On:
            user = request.user
            att_box = AttackBox.objects.get(name="Kali-Attack-Box", user=user)
            # Here we must stop the CountdownTimer by deleting the AttackBoxCountdownTimer object
            # Firstly we must locate it :
            timer_object = AttackBoxCountdownTimer.objects.get(attack_box=att_box)
            timer_object.delete()
            print("Timer stpped")
            started = att_box.poweredOn
            print(started)
            if started == True:
                # 1.1- Connecting to the esxi host
                si = connect()
                print(si)
                # 1.2- Find the attack-Box machine
                vm = find_vm_name(si, "Kali-Attack-Box")
                if vm is None:
                    Disconnect(si)
                    return JsonResponse(
                        {"message": "Unable to locate a machine with that name"},
                        safe=False,
                    )
                else:
                    # 1.3- PowerOff the machine
                    # 1.3.1- Another layer of verification : testing the powerState of the machine
                    # This if statement is valid when an admin powers-off the machine, so to the end user it's started and for the admin it's not
                    if vm.summary.runtime.powerState == "poweredOff":
                        # request.session['started'] = False
                        att_box.poweredOn = False
                        att_box.save()
                        return JsonResponse(
                            {
                                "message": "Machine already Off due to other operation,contact the admin"
                            },
                            safe=False,
                        )
                    else:
                        # Revert To snapshot that has been taken when powering-on the machine
                        revert = revert_to_snapshot(
                            si, "Kali-Attack-Box", "Initial State"
                        )
                        if revert:
                            print("Reverted To snapshot Successfuly")
                        else:
                            print("Unable to revert to snapshot !")
                        # After going-back to the initial state we will power off the machine
                        # I need to verify if all the instances of that machine are off and only the instance of this user is on
                        alive_connections = AttackBox.objects.filter(
                            name="Kali-Attack-Box", poweredOn=True
                        ).count()
                        if alive_connections == 1:
                            print("In that case we terminate the attack box")
                            powered_off = vm_power_off(si, "Kali-Attack-Box")
                            if powered_off:
                                # request.session['started'] = False
                                att_box.poweredOn = False
                                att_box.save()
                                print("Machine Powered-Off succefully")
                                Disconnect(si)
                                return JsonResponse(
                                    {
                                        "message": "poweredOff successfuly",
                                        "link": att_box.machineLink,
                                    },
                                    safe=False,
                                )
                            else:
                                # request.session['started'] = True
                                print("Unable to PowerOff the Machine")
                                return JsonResponse(
                                    {"message": "Unable To powerOff the machine"},
                                    safe=False,
                                )
                        elif alive_connections > 1:
                            # Here we must set poweredOn to false :
                            att_box.poweredOn = False
                            att_box.save()
                            return JsonResponse(
                                {
                                    "message": "poweredOff successfuly",
                                    "link": att_box.machineLink,
                                },
                                safe=False,
                            )
            else:
                return JsonResponse({"message": "Machine already Powered-Off !"})


@login_required
def attack_box_interract(request):
    if request.method == "POST":
        json_data = json.loads(request.body)
        # Interracting with the attack-Box
        if json_data["action"] == "interract":
            user = request.user
            att_box = AttackBox.objects.get(name="Kali-Attack-Box", user=user)
            link = att_box.machineLink
            return JsonResponse({"link": link}, safe=False)


# The Lab page
@login_required
def ongoing_labs(request):
    user = request.user
    # creating a list of userlab objects
    userlabs = list(user.userlab_set.filter(active=True))
    # extract the list of active labs (list of lab objects) for a specifique user
    labs = [userlab.lab for userlab in userlabs]
    data = {"labs": labs}
    return render(request, "ongoinglabs.html", data)


def labs_component(request):
    user = request.user
    # creating a list of userlab objects
    userlabs = list(user.userlab_set.filter(active=True))
    # extract the list of active labs (list of lab objects) for a specifique user
    labs = [userlab.lab for userlab in userlabs]
    data = {"labs": labs}
    return render(request, "labs_component.html", data)


def attack_box_timing(request):
    user = request.user
    print(user.username)
    att_box = AttackBox.objects.get(user=user)
    print(att_box)
    timer_object = AttackBoxCountdownTimer.objects.get(attack_box=att_box)
    if request.method == "POST":
        json_data = json.loads(request.body)
        if json_data["status"] == "expired":
            # Test If the time is really expired :
            remaining_time = timer_object.remaining_time_in_minutes()
            if remaining_time == 0:
                # Stopping the timer
                timer_object.delete()
                # After stopping the timer, the user should have no access to the attack-Box
                return JsonResponse({"message": "Timer Stopped"})
            elif remaining_time > 0:
                return JsonResponse({"message": "Can't Stop Timer"})


def extend_time(request):
    user = request.user
    att_box = AttackBox.objects.get(user=user)
    timer_object = AttackBoxCountdownTimer.objects.get(attack_box=att_box)
    remaining_time = timer_object.remaining_time_in_minutes()
    extended_time = remaining_time + 91
    # delete the timer object :
    timer_object.delete()
    # create new timer object :
    timer = AttackBoxCountdownTimer.objects.create(
        duration_in_minutes=extend_time,  # Set it Later To : 91
        state=AttackBoxCountdownTimer.STATE.RUNNING,
        attack_box=att_box,
    )


def lab_timing(request, lid):
    user = request.user
    lab = Lab.objects.get(id=lid)
    userlab = UserLab.objects.get(user=user, lab=lab)
    timer = LabCountdownTimer.objects.get(user_lab=userlab)
    remaining_time = timer.remaining_time_in_minutes()
    data = {"remaining_time": remaining_time}
    return JsonResponse(data=data, safe=False)


# The redteam's view method
@login_required
def red_team(request):
    return render(request, "red-team.html", {})


@login_required
def profile(request):
    return render(request, "registration/profile.html", {})


# Create your views here.
